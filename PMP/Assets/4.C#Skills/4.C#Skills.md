# C#Skills

### 1.可空修饰符 ？

```C#
// int i = null;   因为值类型不可以被赋值成Null
int? i = null;
```

[有关可空值类型的存储问题](http://www.voidcn.com/article/p-horvnuzr-bsu.html)

#### Nullable

```C#
struct Nullable<T>
{
    bool hasValue;
    T value;
}
```



### 2.Box/UnBox

**装箱**：值类型转引用类型叫，过程：先在堆上分配新存储位置，将值类型数据复制到新存储位置中，将结果变为对新存储位置的引用。

反之，**拆箱** ，过程：判断装箱的值类型是否可被转换成拆卸类型，赋值堆中的存储值。

```C#
int number = 10;
object obj;

obj = number;//boxing		IL_000...  box
number = (int)obj;//Unboxing    IL_000... unbox.any
```

装箱，拆箱会带来性能上的损耗，所以要避免不必要的装箱拆箱。

#### 避免可变的值类型

​	这会让你在装箱拆箱上分不清方向，所以处于规范，避免可变的值类型。





### N.关键字

#### sealed 

​	修饰类避免被继承，修饰方法避免被重写

#### using

​	三种用法

| using System;                          | 引用命名空间       |
| -------------------------------------- | ------------------ |
| **using  Timer = System.Timers.Timer** | **为空间或类型取别名** |
| **using (DisposableSomething){...}** | **作为语句用于定义一定范围，在最后释放对象** |

第三点中，使用的对象必须实现IDisposable接口，保证该对象可被释放。可有多个参数但必须是同类型

```C#
using(Something){....}  相当于

try{...}

finally{ ((IDisposable)Something).Dispose()}
```

#### param

方法参数数组

```C#
public void F(param string[] st){}
F("Hello","World");
```

**注意：参数必须是数组；不能与ref out 组合使用；**



