# C#Skills

### 1.可空修饰符 ？

```C#
// int i = null;   因为值类型不可以被赋值成Null
int? i = null;
```

[有关可空值类型的存储问题](http://www.voidcn.com/article/p-horvnuzr-bsu.html)

#### Nullable

```C#
struct Nullable<T>
{
    bool hasValue;
    T value;
}
```



### 2.Box/UnBox

**装箱**：值类型转引用类型叫，过程：先在堆上分配新存储位置，将值类型数据复制到新存储位置中，将结果变为对新存储位置的引用。

反之，**拆箱** ，过程：判断装箱的值类型是否可被转换成拆卸类型，赋值堆中的存储值。

```C#
int number = 10;
object obj;

obj = number;//boxing		IL_000...  box
number = (int)obj;//Unboxing    IL_000... unbox.any
```

装箱，拆箱会带来性能上的损耗，所以要避免不必要的装箱拆箱。

#### 避免可变的值类型

​	这会让你在装箱拆箱上分不清方向，所以处于规范，避免可变的值类型。



### 3.终结器

​	存在不确定性，不知道何时被回收器调用
```C#
~ClassName(){}  被垃圾回收器主动调用
```

#### IDisposable

​	结合**using**实现确定性终结

```C#
public void Dispose()
{
    ...Dispose     
   	System.GC.SuppressFinalize(this);
}
```

**SuppressFinalize:**的作用是将该实例从（f-reachable）队列中主动移除。

**f-reachable终结队列：**这里存放着即将被执行终结方法的实例。只有终结方法被调用后，才能对这个对象进行垃圾回收，**不然将一直存在引用**。这个时间是不确定的，所以如果可以提前对此进行回收的话，就主动将其移除此队列。



### 4.System.Lazy< T > 

推迟初始化

```C#
Lazy<classA> a = new Lazy<classA>(()=> new classA());
var b = a.value;//当第一次访问value时执行委托
```



### 5.协变与逆变

#### 协变

观点：我们无法将**List< string >** 转换成**List< object >**,因为两者不具有**协变性**。

原因：因为其都具备写入的功能，无法保证数据安全性。

##### 安全协变性

原理：防止对 **T** 的输入

使用 **out** 修饰符

```C#
interface IReadOnlyA<out T>
{
    T First{get;}
}
```

##### 协变的限制

1.只有泛型接口和泛型委托才可以协变；

2.“来源”和“目标”必须是引用类型。

3.接口和委托必须声明为支持协变，编译器必须验证协变类型只用于输出

#### 逆变

与协变相反，限制条件类似。使用 **in** 修饰符，防止对 **T** 的输出

```C#
interface ICompareA<in T>
{
    bool Compare(T a,T b);
}
```

#### 数组的协变

```C#
Fruits[10] f = new Apple[10];//这是被允许的
```

但对于可读可写的类型，这并不是安全的协变。

```C#
IEnumerable<Fruits> f = new Apple[10];//使用只读类型来确保安全
```

**避免不安全的数组协变，考虑使用只读接口来安全转换**



### 6.Func&Action

#### System.Func

代表有返回值的方法，最后一个类型参数总是委托的返回类型。

```C#
public delegate TResult Func<in T1,in T2,out TResult>(T1 a,T2 b) 
```

#### System.Action

代表返回 void 的方法

```C#
public delegate void Action<in T>(T a)
```



### 7.Lambda表达式树

```c#
persons.Where(person => person.Name == "AAAA");
```

对于这个Lambda表达式，在不同情况下具有两种含义。

#### IEnumerable

代表 **委托参数**，比如 **Func< T,bool >**

```c#
public IEnumerable<T> Where<T>(this Ienumerable<T> collection,Func<T,bool> predicate)
```

#### IQueryable

代表 **表达式树参数**，比如 **Expression<Func<T,bool>>**

```C#
public IQueryable<T> Where<T>(this ...,Expression<Func<T,bool>> predicate)
```









***

### N.关键字

#### sealed 

​	修饰类避免被继承，修饰方法避免被重写

#### using

​	三种用法

| using System;                          | 引用命名空间       |
| -------------------------------------- | ------------------ |
| **using  Timer = System.Timers.Timer** | **为空间或类型取别名** |
| **using (DisposableSomething){...}** | **作为语句用于定义一定范围，在最后释放对象** |

第三点中，使用的对象必须实现IDisposable接口，保证该对象可被释放。可有多个参数但必须是同类型

```C#
using(Something){....}  相当于

try{...}

finally{ ((IDisposable)Something).Dispose()}
```

#### param

方法参数数组

```C#
public void F(param string[] st){}
F("Hello","World");
```

**注意：参数必须是数组；不能与ref out 组合使用；**

#### new

| new AClass();                 | 运算符：创建对象调用构造函数                         |
| ----------------------------- | ---------------------------------------------------- |
| **new public int a;**         | **修饰符：显式隐藏从基类继承的成员**                 |
| **class AA<T> where T:new()** | **约束：泛型声明中约束可能用作类型参数的参数的类型** |

#### This

| 代表当前实例                   | this.a                             |
| ------------------------------ | ---------------------------------- |
| **串联构造函数**               | **public A(string a):this(...)**   |
| **拓展方法的第一个参数修饰符** | **public void F(this int a){...}** |

