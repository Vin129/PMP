2021-3-21：4、5

2021-4-10: 6

## 4.类型基础

所有类型都从System.Object派生

**System.Object**

**Public:** 

- Equals:对象相等一致性
- GetHashCode:返回对象哈希码
- ToString:默认返回类型完整名称（this.GetType().FullName）
- GetType :返回Type派生的一个类型实例。

**Protected**:

- ​	MemberwiseClone:创建类型新实例，并将对象实例字段设与this对象的实例字段完全一致返回新实例的引用。
- ​	Finalize：当该对象作为垃圾之后，在实际回收之前，会调用这个虚方法。



**new 的过程:**

1. ​	计算所需子节数：计算类型及其所有基类定义的所有实例字段的子节数（包括对象的额外成员：**类型对象指针、同步块索引**）
2. ​	从托管堆中分配要求子节数，分配对象的内存，初始设置0
3. ​	初始化对象的类型对象指针、同步块索引
4. ​	调用构造器



**类型对象指针**：指向堆上类型对象实例。判断类型是否相等=>该路径是否一致。

**同步块索引**：CLR负责创建同步块，可以把它理解为一个数组，数组中的每一个元素就是一个同步块，同步块索引初始值位负数，表示没有同步。当用lock的时候，会寻找同步块中空闲的部分，将索引设为该空闲部分的索引值（整数），当lock结束后，设回负数。



**CLR 最重要的特性之一就是类型安全。**





***



## 5.基元类型、引用类型、值类型



**基元类型：编译器直接支持的数据类型。基元类型直接映射Framework类库（FCL）中存在的类型。例如int 直接映射 System.Int32**



**基元类型操作：checked、unchecked  开关溢出检查**



**引用类型四个事实：**

1. 内存必须从托管堆分配
2. 堆上分配的每个对象都有额外成员，这些成员必须初始化
3. 对象中其他子节总是设为零
4. 从托管堆分配对象时，可能强制执行一次垃圾回收



值类型种类：结构、枚举

值类型与引用类型的区别：

- 值类型对象有两种表示形式：未装箱与已装箱，引用类型总是处于已装箱形式。
- 值类型从System.ValueType派生，它重写了Equals和GetHashCode。
- 值类型中不应引入任何虚方法、所有方法都不能抽象，所有方法都隐式密封，不可重写。
- 引用类型对象包含堆中对象的地址，默认初始化为null。
- 值类型赋值：逐字段复制。引用类型的赋值：只复制内存地址。
- 对值类型对象的操作不会影响其他值类型，引用类型则可能会影响其他引用类型对象。
- 未装箱的值类型不用等待垃圾回收



**装箱过程:**

- ​	从托管堆中分配内存，分配的内存量是 值类型各字段所需内存量，加上所有对象的两个额外成员（对象类型指针、同步块索引）。
- ​	值类型的字段复制到新分配的对内存。
- ​	返回对象地址。

**拆箱过程：**

- ​	获取堆上对象各个字段的地址
- ​	将字段包含的值从堆复制到基于栈的值类型实例中。



**拆箱不是直接将装箱过程倒过来，拆箱代价比装箱低很多。拆箱其实就是获取指针的过程，后面紧接着发送一次字段复制。**



***



## 6.类型和成员基础

CLR 如何调用虚方法：

​	CLR提供了两个方法调用指令：

- ​	**call**

  该IL指令可调用静态方法、实例方法、虚方法

  call一般用于以非虚方式调用虚方法

  call 编译时不会做null判断

- ​	**callvirt**

  IL指令可调用实例方法和虚方法。

  用callvirt 调用虚实例方法，CLR调查发出调用的对象实际类型，然后以多态方式调用。

  callvirt 的调用在编译时会生成代码验证实例是否为null，并抛出**NullReferenceException**异常

  因为多了额外检查，callvirt 执行速度要稍慢于 call 