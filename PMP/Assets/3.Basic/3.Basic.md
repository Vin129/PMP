# Basic

## 资料（References）

[算法导论公开课](http://open.163.com/special/opencourse/algorithms.html)

[leetcode](https://leetcode-cn.com/)

***

##  数据结构（DataStructure）

### 线性表

列表 ：简单数组，连续

链表：Head + Next 不连续

[手写链表](https://mp.weixin.qq.com/s/hKjkITbCRcnZBafpjiwWJA)

跳跃表：TODO

栈：Last In First Out 先进后出 ，Push + Pop

队列：先进先出 ， Enqueue + Dequeue

***

### 树

#### 一般树

**节点由 FirstChild（第一个子节点） + NextSibling（从左至右，下一个兄弟节点）构成**

​	先序遍历：处理子节点前先处理自身

​	后序遍历：先处理子节点，再处理自身

#### 二叉树

**Left + Right 左右两子树构成，深度理想状态为logN**

​	先序：节点、左、右

​	中序：左、节点、右

​	后序：左、右、节点

#### 二叉查找树

**二叉树，且 左子树值一定小于其根节点的值，右子树的值一定大于根节点的值，不存在相等的节点。**

**删除操作：叶子就直接删除，存在一个子节点则连接上下，若存在两个，则将该节点右侧的最小值（叶子）替代该节点的值，并删除叶子。**

**优点：查找速度理想状态控制在O(logN)**

**缺点：会导致不平衡，导致查找效率达不到O(logN)，尤其是进行多次删除操作后，因为删除都是拿右树的叶子补充，会导致左树高于右树的情况。**

#### AVL 树

**平衡的二叉查找树，节点的左右子树高度差不超过1**

**右旋：（左子树高于右子树，且是左-左型）顺时针旋转两个节点，使得父节点被自己的左孩子取代，左孩子的右子节点变成自己的左孩子，而自己成为自己的右孩子**

![](G:\Vin129P\PMP\PMP\Assets\9.UGUI\Texture\640.gif)

**左旋：（右高于左，且是右-右型）逆时针旋转两个节点，使得父节点被自己的右孩子取代，右孩子的左子节点变成自己的右孩子，而自己成为自己的左孩子**

![](G:\Vin129P\PMP\PMP\Assets\9.UGUI\Texture\641.gif)



**另外两种情况**

**右-左型：先右旋，再左旋**

![](G:\Vin129P\PMP\PMP\Assets\9.UGUI\Texture\avl1.png)

![](G:\Vin129P\PMP\PMP\Assets\9.UGUI\Texture\avl2.png)



**左-右型：先左旋，再右旋**

**优点：查找速度保持在O(logN)**

**缺点：由于要保持平衡，所以添加操作会存在左旋右旋的操作，频繁增删操作会影响性能。**

#### 伸展树SplayTree



#### B树

平衡多路查找树

M阶的B树：

​	每个节点最多包含2M-1个关键字，除根节点外每个节点至少有t-1个关键字。

​	含有n个关键字的节点可以有n+1个子树

​	所有的树叶都在相同的深度上







***

## 设计模式

### 状态模式

#### FSM

有限状态机（Finite State Machine）

**1.拥有一组状态，并且这组状态之间进行切换。**

**2.同一时刻只能处在一种状态。**

**3.状态机会接收一组输入或者事件。**

**4.每一个状态有一组转换，每一个转换都关联着一个输入并指向另一个状态。**

```C#
interface IState
{
    void Enter();
    void Update();
    void Exit();
}

interface IFSM
{
    IState mCurrentState{get;set;}
    List<IState> mStateList{get;set;}
    Dictionary<IState,Dictionary<string,IState>> TranslationDict{get;set;}
}
```













***

## 算法（Algorithm）

### 排序

#### 插入排序 Insertion Sort (O(n^2)  O(1))

```fake
InsertionSort A[n]
for i = 0 ,i < n - 1 do
	key = A[i+1]
	c = i
	while(c>=0 and key < A[c])
		A[c+1] = A[c]
		c--
	end
	A[c+1] = key
end
```



#### 归并排序 MergeSort （O(nlogn)  O(n)）

```fake
MergeSort A[n]
function MergeSort(A)
	if A.Length < 2 then
		return A
	end
    Left = A[0,n/2]
    Right = A[n/2+1,n]
    return Merge(MergeSort(Left),MergeSort(Right))
end

funtion Merge(L,R)
	n = L.Length + R.Length
	M[n]
	for index = 0,i = 0,j = 0 to n-1 index++ do
		if i>= L.Length then
			M[index] = R[j++]
		elseif j>= R.Length then
			M[index] = L[i++]
		elseif L[i] < R[j] then
			M[index] = L[i++]
		else
			M[index] = R[j++]
	end
	return M
end
```



### 斐波那契

#### 递归 （O(2^(n/2) ~ O(2^n))  O(n)）

```fake
Fibonacci N
funtion FiboByRecursion(N)
	if N == 0 then
		return 0
	elseif N== 1 then
		return 1
	else
		return FiboByRecursion(N-1) + FiboByRecursion(N-2)
	end
end
```

#### 分治

1. O(n)

```fake
rs = 0 f0 = 0  f1 = 1
if i == 0  return f0
if i == 1  return f1
for i = 1,i<n,i++ do
	rs = f0 + f1; f0 = f1;f1 = rs; 
end
return rs
```

2. O(n^3)

$$
\left\{ \begin{matrix}
F_{n+1} & F_n \\ 
F_n & F{n-1}  \\  
\end{matrix} \right\} =
\left\{ \begin{matrix}
1 & 1 \\ 
1 & 0  \\  
\end{matrix} \right\}^n
$$

### 斯特拉森矩阵乘法  （O(n^log7)）

[链接]([https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%8B%89%E6%A3%AE%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5996351?fr=aladdin](https://baike.baidu.com/item/斯特拉森矩阵乘法/5996351?fr=aladdin))





***

