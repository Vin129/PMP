## 编译

1. 动态链接库/静态链接库



## 网络

1. 五层结构：应用层—传输层—网络层—网络链路层—物理层

2. 三次握手：确认双方的收发能力，建立连接通道。

   四次挥手：确认双方都收到了断开连接的请求并回复，避免死等的情况

3. UDP是用户数据报，是不可靠的传输方式。

   可靠的UDP:KCP/ENet，原理是上部封装一层用于处理顺序、准确、重传的组成部分，间接达到TCP数据头的效果。

4. Get:用于向服务器请求数据的操作，在url中是名文可见的。

   Post:用于传递修改数据的操作，传输的数据在url中是不可见的。

5. 一般向服务器请求时会带上拉去的子节信息段，start—end 告知服务器从子节的什么地方传输给我。



## 数据结构

1. 链表：回路、环、翻转





## 算法

1. A星寻路
2. Navmesh寻路



## 设计模式

1. 状态机：

   ​	四大概念：状态、事件、动作、变换

   ​	通过事件执行动作从而进行状态的转换

   ​	优点：逻辑清晰符合人脑思维，易于理解

   ​	缺点：当状态非常多的时候，相互转换就变得复杂，难以维护。

   ​	优化方法：分层状态机（对状态进行抽象归类，形成层次状态，每层中有各个小状态）

   

   行为树：是一种树形的父子节点之间的逻辑结构，通过扩展节点的功能来实现复杂的行为逻辑

   ​	行为树的本质是树状节点

   ​	四类节点：

   复合：选择、顺序、并行（并行选择 False、并行顺序 True、并行混合）

   修饰：反向、直到失败、总是失败、计数、时间

   条件：满足True/不满足False

   行为

   行为树节点返回：**成功True或失败False或Running正在执行**

2. 观察者：Subject执行Notify操作响应Observer的Update。

   监听者：事件源、事件监听器、事件对象。当事件源上发生操作时，会调用事件监听器，传递事件对象，事件监听器对事件对象进行不同的响应。

   二者的区别：监听者比观察者多了一个事件对象，通过事件对象可以更灵活的触发不同的响应。

   代理模型：阻止对本源的操作，一切操作交由中间代理进行处理。

3. MVC：

   ​	Model 用于封装相关数据以及对数据处理方法

   ​	View 负责数据展示的视图

   ​	Controller 控制器 用于M、V的连接

   ​	被动MVC:我们一般使用的都是被动MVC，模型对视图和控制其一无所知，它仅仅是被使用，控制其使用视图，并通知它更新数据。

   ​	主动MVC:控制其响应事件通知模型进行数据变化，模型会通知视图刷新。

   ​	**Model在MVC架构中作用非常重要，他是业务逻辑真正的实现层。Controller仅是桥梁，用来解耦View和Model，让UI与逻辑分离。**	

   ​	优点：分离了视图与业务层，耦合低，可维护性高，易于理解。

   ​	缺点：因为Model过于重要，对于复杂变化的View差异，使得Model难以应付。随着View复杂性增多，Model会膨胀。

4. MVP:

   ​	Model  IView Presenter

   ​	**特点：这里的V特指View的接口，这是将UI提炼抽象出来的接口，任何界面实现了该接口都可以复用Presenter和Model**

   ​	MVP中，Presenter完全把Model和View进行了分离，主要程序逻辑在P中实现，而且P与具体的View没有直接联系，之和定义好的接口交互，可以保存P的不变和重用。

   ​	优势：M V 完全分离，高效的重用P，逻辑在P中，可以脱离UI做单元测试。

   

5. MVVM:

   Model View ViewModel

   一个VM和一个V匹配，没有IView接口，所有View变化都会更新到ViewModel中，VM的变化也会同步到View上显示。

   ​	特点：VM与V是一种绑定关系，VM中的属性都实现了observable这样的接口，即当属性set时会触发修改事件使绑定的UI刷新。



## Unity

1. LAMA：是整体压缩，包体小，但解压时间长，且解压完之后会将未使用部分压缩成LZ4

   LZ4：块压缩技术，将各个资源文件单独进行压缩，只会解压需要使用的资源，包体大小会略比LAMA大。

2.  WWW加载AB时会保留一份byte资源，内存会比使用loadformfeil大一倍。

3. JIT：Unity 早期使用Mono 虚拟机来解决跨平台的问题，打包时会将C#等dll转成IL文件，通过Mono虚拟机来动态运行，缺点是Mono维护困难，不同平台需要更新维护，Mono版权原因更新缓慢。

   AOT：提前编译，Unity也提供了IL2CPP的打包方案，将IL转换成CPP到C++文件，C++ 可以更好的在各个平台的环境下运行，性能也有所提升。

4. 特殊文件夹作用

5. GC 原理

6. 协程依附于线程，只是线程中的一部分，协程根本上是迭代器，通过yeild return 这种形式会形成一个可枚举类，通过StartCoroutine被加入Update刷新列表中，通过Current与MoneNext()进行状态切换，达到被挂起并在特点时刻执行的效果。

   线程：线程
   
7. rotation 是什么类型表达的：四元数

8. 骨骼动画原理

9. GUID：该文件的唯一ID，通过GUID就可以找到工程文件中的这个文件。AssetDatabase.GUIDToAssetPath和AssetDatabase.AssetPathToGUID

   FileID(LocalID)：记录子文件的ID

   通过GUID找到任一文件，通过FileID找到其中某个子文件



## C#

1. await async

2. 协程原理

3. 线程

4. GC 原理 ： mark - sweep 

   mark:判断可达性->判断是否存在终结方法(Finalize) 有则交由终结队列去执行终结方法。

   清除：Compact算法，移动剩余内存块，使其连续（清除内存碎片）

   分代：0，1，2代

5. 看就是了

6. ArrayList是object的，List是泛型，ArrayList会有装箱的问题影响性能

7. todo

8. 看源码吧

9. todo

10. 计数所有类中成员所需子节数（包括额外成员的子节数：类型对象指针、同步块索引）

    托管堆中分配要求的子节数，对象分配内存。

    初始化 **类型对象指针**、**同步块索引**

    调用构造器





## Lua

1. ToLua、XLua、ILRunTime 各自的特点优缺
2. XLua Hotfix 原理
3. GC 原理



## 其他

1. 浮点数运算的精确性